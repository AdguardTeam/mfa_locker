# AW-2175: Add scrollbars to the application screens

Status: PRD_READY

## Context / Idea

Add scrollbars to the application screens in the MFA Demo example app. This enhancement improves usability, particularly on desktop platforms (macOS, Windows) where users expect visible scrollbars for navigating scrollable content. Currently, the application uses scrollable widgets (ListView, SingleChildScrollView) without explicit scrollbar indicators, which can make it difficult for users to recognize that content is scrollable or to navigate long lists efficiently.

## Goals

1. **Improve usability on desktop platforms**: Provide visible scrollbars that match platform conventions for macOS and Windows users.
2. **Enhance discoverability**: Make it visually apparent when content is scrollable.
3. **Maintain mobile experience**: Ensure mobile platforms continue to work naturally with touch-based scrolling (scrollbars can be subtle or hidden by default).
4. **Consistent behavior**: Apply scrollbar patterns uniformly across all scrollable screens in the application.

## User Stories

1. **As a desktop user**, I want to see scrollbars on scrollable content so that I can quickly navigate long lists and recognize when content extends beyond the visible area.

2. **As a user viewing the entries list**, I want a scrollbar on the entries list so that I can quickly scroll through many stored entries.

3. **As a user on the settings screen**, I want to see a scrollbar when settings options exceed the screen height so that I can scroll to see all available settings.

4. **As a mobile user**, I want scrollbars to behave according to platform conventions (typically auto-hiding) so that my experience is not cluttered with unnecessary UI elements.

## Main Scenarios

### Scenario 1: Unlocked Screen with Many Entries
**Given** the user has unlocked the storage and has more entries than fit on screen
**When** the entries list is displayed
**Then** a scrollbar should be visible (on desktop) or available (on mobile) to navigate the list

### Scenario 2: Settings Screen with Overflow Content
**Given** the user opens the Settings screen
**When** the content exceeds the visible viewport (e.g., on a small screen or with many settings)
**Then** a scrollbar should indicate scrollable content is available

### Scenario 3: Bottom Sheet Dialogs
**Given** the user triggers an authentication bottom sheet
**When** the keyboard appears and pushes content
**Then** the content should remain scrollable with appropriate scroll indicators

### Scenario 4: Entry Value Dialog
**Given** the user views an entry with a long value
**When** the dialog appears
**Then** the value area should be scrollable with a visible scrollbar if content overflows

## Success / Metrics

1. **Functional**: All scrollable content areas display scrollbars appropriately based on platform conventions.
2. **Visual consistency**: Scrollbars use the default Flutter Scrollbar widget styling (platform-adaptive).
3. **No regression**: Touch-based scrolling on mobile continues to work as expected.
4. **Code quality**: Implementation follows the existing patterns and conventions in the codebase.

## Constraints and Assumptions

### Constraints
- Use the standard Flutter `Scrollbar` widget for platform-adaptive behavior.
- Follow the KISS principle - no complex custom scrollbar implementations.
- Maintain the existing architecture (no new abstractions or layers).
- Keep changes minimal and focused on wrapping existing scrollable widgets.

### Assumptions
- The existing scrollable widgets (`ListView`, `SingleChildScrollView`) are correctly configured.
- Flutter's default `Scrollbar` behavior (show/hide, thumbVisibility) is acceptable for MVP.
- Desktop platforms (macOS, Windows) will benefit most from visible scrollbars.
- Mobile platforms will use platform-default scrollbar behavior (typically auto-hiding).

## Screens Requiring Scrollbar Integration

Based on codebase analysis, the following screens/widgets contain scrollable content:

| File | Widget | Scrollable Element |
|------|--------|-------------------|
| `unlocked_screen.dart` | `EntriesListView` | `ListView.builder` for entries |
| `settings_screen.dart` | Settings content | `ListView` for settings options |
| `authentication_bottom_sheet_content.dart` | Auth dialog | `SingleChildScrollView` |
| `entry_value_dialog.dart` | Entry value display | `SingleChildScrollView` |
| `timeout_picker_dialog.dart` | Timeout options | `SingleChildScrollView` |

### Implementation Notes

The simplest approach is to wrap existing scrollable widgets with `Scrollbar`:

```dart
// Example pattern
Scrollbar(
  child: ListView.builder(...),
)
```

For widgets already using `SingleChildScrollView`, provide a `ScrollController` if not already present:

```dart
final _scrollController = ScrollController();

Scrollbar(
  controller: _scrollController,
  child: SingleChildScrollView(
    controller: _scrollController,
    child: ...
  ),
)
```

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Visual clutter on mobile | Low | Low | Use platform-default behavior; scrollbars auto-hide on mobile |
| Scrollbar overlapping content | Low | Medium | Ensure proper padding in affected widgets |
| Breaking existing scroll behavior | Low | Medium | Test all scrollable screens after changes |

## Open Questions

None - the scope and implementation approach are straightforward based on Flutter's built-in `Scrollbar` widget.

---

## References

- Flutter Scrollbar documentation: https://api.flutter.dev/flutter/material/Scrollbar-class.html
- Project conventions: `/docs/conventions.md`
- Project vision: `/docs/vision.md`
