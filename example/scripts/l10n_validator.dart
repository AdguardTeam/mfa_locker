import 'dart:convert';
import 'dart:io';

// ignore_for_file:avoid_print

void main() {
  final inUse = getStringsInUse(Directory('./lib'));
  final arb = getStringsFromArb(File('./lib/common/localization/arb/intl_en.arb'));

  // the root algorhitm is: get all the used strings from the sources
  final extra = inUse.difference(arb);
  // then get all the defined string keys from the ARB
  final missing = arb.difference(inUse);

  // and diff two sets twice
  if (extra.isNotEmpty) {
    print("These strings present in the sources files aren't present in the ARB:\n\n$extra");

    exit(255);
  }

  if (missing.isNotEmpty) {
    print("These strings present in the ARB files aren't present in the sources:\n\n$missing");
  }
}

// find the strings matching patterns `context.ln.(*) / AppLocalizations.of(context).(*)`
// most likely these are the l10n keys used in project
//
// it's more like an example of approach and, probably, it's better to replace the current inmlementation with
// more strict one based on exporting autogenerated AppLocalizations
Set<String> getStringsInUse(Directory dir) {
  List<String> strings = [];

  dir
      .listSync(recursive: true)
      .whereType<File>()
      .where((file) => file.path.endsWith('.dart'))
      .map((file) => file.readAsStringSync())
      .map((content) => extractIds(content))
      .forEach(strings.addAll);

  return strings.toSet();
}

// get all the defined string keys in the EN ARB file.
// the algorhitm is deadly simple: at first, get all defined JSON keys and the filter out the keys' metadata
// that start from `@` sign.
Set<String> getStringsFromArb(File file) {
  final input = file.readAsStringSync();
  final map = jsonDecode(input) as Map<String, Object?>;

  return map.keys.where((key) => !key.startsWith('@')).toSet();
}

Set<String> extractIds(String content) {
  final result = <String>{};

  final regexLn = RegExp(
    r'\bln\.(\w+)',
    caseSensitive: false,
    multiLine: true,
  );

  final regexContextLn = RegExp(
    r'context\.ln\.(\w+)',
    caseSensitive: false,
    multiLine: true,
  );

  final regexContextOf = RegExp(
    r'AppLocalizations\.of\(context\)\.(\w+)',
    caseSensitive: false,
    multiLine: true,
  );

  result.addAll(regexLn.allMatches(content).map((m) => m[1]).nonNulls);
  result.addAll(regexContextLn.allMatches(content).map((m) => m[1]).nonNulls);
  result.addAll(regexContextOf.allMatches(content).map((m) => m[1]).nonNulls);

  return result;
}
